# 15~20

- [15~20](#1520)
- [15. Write The Comments First](#15-write-the-comments-first)
  - [지연된 주석은 나쁜 주석이다](#지연된-주석은-나쁜-주석이다)
  - [주석을 가장 먼저 작성하기](#주석을-가장-먼저-작성하기)
    - [주석 가장 먼저 작성하기의 이점](#주석-가장-먼저-작성하기의-이점)
  - [Red Flag: Hard to Describe](#red-flag-hard-to-describe)
  - [주석 우선 접근 방식은 실용적이다](#주석-우선-접근-방식은-실용적이다)
  - [결론](#결론)
- [16. Modifying Existing Code](#16-modifying-existing-code)
  - [전략적 유지](#전략적-유지)
  - [주석 유지하기: 주석을 코드 근처에 둬라](#주석-유지하기-주석을-코드-근처에-둬라)
- [17. Consistency](#17-consistency)
  - [일관성 보장하기](#일관성-보장하기)
  - [새로운 좋은 아이디어보다는 일관성을 우선하라](#새로운-좋은-아이디어보다는-일관성을-우선하라)
- [18. Code Should be Obvious](#18-code-should-be-obvious)
  - [코드가 명확하다는 건?](#코드가-명확하다는-건)
  - [코드를 명확하게 만드는 것들](#코드를-명확하게-만드는-것들)
  - [Red Flag: Nonobvious Code](#red-flag-nonobvious-code)
  - [결론](#결론-1)
- [19. Software Trends](#19-software-trends)
  - [객체지향 프로그래밍과 상속](#객체지향-프로그래밍과-상속)
  - [애자일 개발](#애자일-개발)
  - [단위 테스트](#단위-테스트)
  - [테스트 주도 개발 - TDD](#테스트-주도-개발---tdd)
  - [디자인 패턴](#디자인-패턴)
  - [Getter와 Setter](#getter와-setter)
  - [결론](#결론-2)
- [20. Designing for Performance](#20-designing-for-performance)

# 15. Write The Comments First

> 주석달기를 디자인 프로세스의 일부분으로 포함하라

- 많은 개발자들이 문서를 작하는 것을 개발 프로세스의 가장 마지막으로 미룬다.
  - 그리고 이는 품질이 좋지 않은 문서를 작성하는 가장 확실한 방법 중 하나이다…!
- 주석을 작성하기에 가장 좋은 시점은 코드를 작성하면서 프로세스를 시작하는 시점이다
  - 주석을 먼저 작성하면 문서가 디자인 프로세스의 일부가 되고
  - 이것은 더 나은 문서를 남길뿐만 아니라 더 나은 디자인을 만들고 문서 작성 프로세스를 더 즐겁게 만든다.

## 지연된 주석은 나쁜 주석이다

- 대부분의 개발자는 주석 달기를 미룬다.
  - 대부분 그 이유로는 코드가 여전히 변경되고 있고 안정화될 때까지 기다리는 게 좋다고 말한다.
  - 하지만 여기는 또 다른 이유가 있는데, **문서화를 고된 작업으로 보기 때문이다. 그래서 이들은 문서화를 최대한 미룬다.**
- 하지만 불행하게도 이 접근 방식은 몇 가지 부정적인 결과를 만들다
  - **문서화 지연은 종종 문서가 전혀 작성되지 않는다는 것을 의미한다.**
    - 한 번 미루기 시작하면 이후에 미루기 더 쉬워지고 코드는 시간이 지날 수록 안정화될텐데, 그 때가 되면 문서화를 챙기는 것보다 새 기능을 개발하는 것이 더 좋은 것이라고 합리화하기 쉽다.
    - 결국 이렇게 문서화되지 않은 코드들이 탄생한다

## 주석을 가장 먼저 작성하기

**주석을 가장 먼저 작성하는 접근 방식을 소개한다.**

- 먼저, 새 클래스의 경우 클래스 인터페이스 주석을 **먼저** 작성한다.
- 그 다음으로 가장 중요한 public method에 대해서 인터페이스 주석 및 서명을 작성하고 **method 바디는 비워둔다**
  - 그리고 기본 구조가 옳다고 느껴질 때까지 이 과정을 반복한다.
- 그리고 구현을 시작해서 마친 뒤에 필요하다고 판단되면 구현 주석을 추가한다.
  - 구현하는 동안에 보통 추가 메서드, 변수가 필요함을 발견하고 각각의 새 메서드에 대해 동시에 주석을 작성한다.
- 이 과정을 거치면 주석이 작성되지 않는 코드없이 개발이 완료된다.

### 주석 가장 먼저 작성하기의 이점

주석을 가장 먼저 작성하는 방식은 세 가지 이점이 있다.

- **`더 나은 주석을 만든다.`**
  - class를 설계하면서 주석을 작성하면 주요 설계 문제가 작업자의 머리 속에 환기되고 기록하기 쉽다.
  - 그리고 인터페이스 주석을 작성하면 구현에 방해받지 않고 메서드의 추상화 및 인터페이스에 집중할 수 있다.
  - 그리고 코딩 및 테스트 과정에서 주석에 문제가 있음을 알아차리면 이 과정에서 주석이 개선될 것이다.
- **`주석은 시스템 설계를 개선한다.`**
  - 좋은 추상화는 좋은 시스템 설계의 기본이고
  - 이 추상화를 설명하는 주석을 작성하면 피드백을 빠르게 할 수 있다.
  - 그리고 **긴 주석이 필요한 경우 좋은 추상화가 없다는 위험 신호이다.**
    - 클래스는 깊어야하고 최고의 클래스는 인터페이스가 매우 단순하면서도 강력한 기능을 제공하는 것이다
    - **따라서 이 인터페이스 주석이 중요하다.**
- `주석 작성이 좀 더 즐거워진다.`
  - 프로그래밍의 가장 즐거운 부분 중 하나는 새로운 크래스의 초기 설계 단계인데, 주석을 먼저 작성하면 이 단계에서 피드백할 수 있고 좀 더 좋은 디자인을 가져갈 수 있게 된다.
  - 좋은 디자인에 대한 느낌은 개발자의 자부심 원천이고 이는 우리를 즐겁게 한다.

## Red Flag: Hard to Describe

- 주석을 작성하는 것이 어렵다면 설명하고 있는 대상의 디자인에 문제가 있을 수 있음을 나타내는 지표다
- **메서드나 변수를 설명하는 주석은 단순하면서도 완전해야한다.**

## 주석 우선 접근 방식은 실용적이다

- 이제 주석을 늦게 작성하는 사람들의 의견으로 주석 재작업에 대해서 비용이 크다는 주장에 대해 살펴보자
  - 먼저 코드와 주석을 수정하는 시간을 포함하여 코드와 주석을 함께 입력하는데 소요되는 시간은 **개발 시간의 약 10% 이상이 될 가능성이 매우 낮다.**
  - 주석을 끝까지 미루면 이것의 일부만 절약될 뿐이다.
- 그리고 주석을 먼저 작성하는 것은 코드 작성을 시작하기 전에 추상화가 더 안정적이라는 것을 의미한다.
  - 이렇게 하면 코드 작성 시간이 절약될 것이다.
  - 반대로 코드를 먼저 작성하면 코드를 작성할 때 추상화가 더 발전할 가능성이 높으므로 주석 우선 접근 방식보다 더 많은 코드 수정이 필요하다.
- **따라서 주석 우선 접근 방식은 저렴하고 실용적이다.**

## 결론

- 주석을 먼저 작성해보지 않았다면 한 번 시도해보라!
- 그리고 주석, 디자인의 품질 및 소프트웨어 개발의 전반적인 즐거움에 어떤 영향을 미치는지 생각해보라!

# 16. Modifying Existing Code

- 이전 장들에서 초기 설계 및 구현 중에 복잡성을 줄이는 방법에 대해 설명했다면 **이 장에서는 시스템이 발전함에 따라 복잡성이 점점 커지는 것을 방지하는 방법에 대해 설명한다.**
- 소프트웨어 개발은 반복적이고 점진적인 방식이고
대규모 소프트웨어 시스템은 각 단계에서 새로운 기능을 추가하고 기존 모듈을 수정하는 일련의 진화 단계를 통해 개발된다.
  - 그리고 이는 시스템 설계가 지속적으로 진화하고 있음을 의미한다.
- 따라서 처음부터 시스템에 대한 올바른 설계를 구상하는 것은 불가능하고
  - 성숙한 시스템의 설계는 초기 개념보다는 시스템이 진화하는 동안 변경된 사항에 의해 더 많이 결정된다.

## 전략적 유지

**기존 코드 수정에는 전술적이 아니라 최대한 전략적으로 접근하라**

- `전술적 프로그래밍`의 주요 목표는 복잡도를 높이더라도 **빠르게 작동**시키는 것..!
- `전략적 프로그래밍`에서의 가장 중요한 목표는 **훌륭한 시스템을 설계**하는 것..!
- **전술적 접근 방식은 당연하게도 매우 빠르게 지저분한 시스템 설계로 이어진다. 유지하는 것은 전략적으로 진행하라**
- 경제적으로 비용을 생각했어도 올바른 방법으로 리팩토링하는 데 시간이 오래 걸리고 일정이 촉박한 경우에 전술적을 접근하자고 결정을 내릴 수 있다.
  - 하지만 이런 경우에도 정말 이게 최선인지? 더 나은 방안은 없을지 다시 한 번 고려하라.
  - **그리고 당장에 여유가 없다면 현재 마감일 이후에 리팩토링 작업할 수 있도록 일정을 타협하라.**
- **모든 개발 조직은 전체 노력의 작은 부분을 정리 및 리팩토링에 사용할 계획을 세워야한다 이는 장기적으로 보면 적절한 비용이다.**

## 주석 유지하기: 주석을 코드 근처에 둬라

- 코드 수정에 따라 주석이 업데이트되도록 하는 가장 좋은 방법은 코드 가까이에 주석을 배치하여 개발자가 코드를 변경할 때 이 주석을 볼 수 있도록 하는 것이다.
- 주석은 커밋 로그가 아니라 코드에 속한다. **커밋 로그를 주석으로 사용하지 말라.**
  - 커밋 메시지를 작성할 때 개발자가 향후 해당 정보를 사용해야 하는지 스스로에게 물어보고 그렇다면 이 정보를 코드에 문서화하라
  - 커밋 메시지는 나중에 로그로 찾을 수 있지만 올바른 로그를 찾는 과정은 힘들고 지루할 것이다.
  - 개발자가 가장 잘 볼 수 있는 위치에 문서를 배치하라. 커밋 로그는 이것에 적합하지 않다.
- **주석을 최신 상태로 유지하기 위해 중복을 피하라.**
  - 문서가 중복되면 개발자가 모든 관련 사본을 찾고 업데이트하기가 더 어렵다. → SSOT 활용하기 + 참조 링크 이용하기!
    - e.g. Foo 명령을 구현합니다. 자세한 내용은 사용 설명서를 참조하십시오.
  - 독자가 코드를 이해하는 데 필요한 모든 문서를 쉽게 찾을 수 있도록 하는 것이 중요하지만 그렇다고 모든 문서를 작성해야 한다는 의미는 아니다.

# 17. Consistency

**일관성이 주는 이점은 신뢰를 준다는 점에서 명확하다**

- `코드 스타일 가이드라인`은 코드를 읽기 쉽게 만들고 일부 오류를 줄일 수 있다.
- `여러 구현이 있는 인터페이스`는 인터페이스의 구현체 하나만 이해하면 다른 구현체를 사용하더라도 이미 그 인터페이스가 제공해야 할 기능을 알고 있기 때문에 다른 구현도 이해하기 쉬워진다.
- `디자인 패턴`은 특정 공통 문제에 대해 일반적으로 허용되는 솔루션으로 기존 디자인 패턴을 사용핳여 문제를 해결할 수 있다면 구현이 더 빠르게 진행되고 작동할 가능성이 높아지며 독자에게 코드가 더 명확해진다.
- `불변성`은 코드에서 고려해야 하는 특별한 경우의 수를 줄이고 코드의 동작에 대해 더 쉽게 추론할 수 있도록 한다.

## 일관성 보장하기

특히 많은 사람들이 장기간에 걸쳐 프로젝트에 참여하는 경우 일관성을 유지하기 어렵다.

- 한 그룹의 사람들이 다른 그룹에서 확립된 규칙에 대해 모를 수도 잇고
- 회사에 새로 들어오는 사람은 규칙을 모르기 때문에 본의 아니게 관습을 위반하고 기존 관습과 충돌하는 새로운 관습을 만들어 낸다.

이제 **일관성을 설정하고 유지하기 위한 몇가지 팁에 대해서 살펴보자**

- 코딩 스타일 지침과 같은 가장 중요한 전반적인 규칙을 나열하는 `문서를 만들고 눈에 잘 띄는 위치에 배치`하라. 그리고 그룹에 새로 가입하는 사람들이 `문서를 읽도록 권장`하고 기존 사람들도 `가끔씩 검토하도록 하라`.
  - 이미 다양한 조직의 스타일 가이드가 웹에 게시되어 있고 이 중 하나부터 시작하는 것을 고려하라
- 불변량과 같이 더 `지역화된 규칙의 경우 코드에서 문서화할 적절한 지점을 찾아라`.
  - 규칙을 적어두지 않으면 다른 사람들이 따를 가능성이 적다.
- 도구를 사용해 `억지로 지키도록 구조적으로 강제하라`
  - 좋은 문서가 잇더라도 개발자가 모든 규칙을 기억하기는 어렵다. 규칙을 적용하는 가장 좋은 방법은 **도구를 만들어 구조적으로 강제하는 것이다.**
  - e.g. lint 등등

## 새로운 좋은 아이디어보다는 일관성을 우선하라

- 최대한 기존 규칙을 변경하지마라
- 기존 관습을 개선하려는 충동에 최대한 저항하라
- 더 나은 아이디어를 갖는 것은 대부분 불일치를 만들 충분한 변명이 되지 않는다.
  - 실제로 그 새로운 아이디어가 더 나을 수도 있지만, 불일치에 대한 일관성의 가치는 거의 항상 한 접근 방식의 가치보다 크다
  - 그리고 다시 일관성을 맞추는 데 비용이 많이 든다
- 그럼에도 새로운 아이디어를 반영하고 싶다면 다음 두 가지 질문을 스스로에게 해봐라
  - 기존 방식에서는 사용할 수 없었던 접근 방식을 정당화하는 중요한 정보가 있는가?
  - 새로운 접근 방식이 훨씬 더 나아서 이전에 작성했던 코드를 모두 업데이트하여 일관성을 맞추는 데 시간을 할애할 가치가 있는가?
- 조직에서 두 질문에 모두 YES 라고 동의한다면 업그레이드를 진행하라
  - 하지만 여전히 다른 개발자가 새 규칙에 대해 알지 못할 위험이 있으므로 나중에 이전 접근 방식을 다시 도입할 수 있다.
  - 전반적으로 이미 확립된 규칙을 다시 고려하는 것은 개발자 시간을 잘 활용하는 경우가 거의 없다

# 18. Code Should be Obvious

- `모호함`은 복잡성의 두 가지 원인 중 하나이다.
  - 다른 하나는 의존성
- 모호함은 시스템에 대한 중요한 정보가 새로운 개발자에게 명확하지 않을 때 발생하고
- **모호함을 해결하는 방법은 코드를 명확하게 만드는 것이다.**
- 이 장에서는 코드를 명확하게 만드는 몇가지 요소에 대해 살펴보자

## 코드가 명확하다는 건?

- 코드가 명확하다는 것은 많은 생각 없이 코드를 빠르게 읽을 수 있고
- 코드의 동작이나 의미에 대한 첫 번째 추측이 올바르다는 것을 의미한다.
- 코드가 명확하면 독자는 코드 작업에 필요한 모든 정보를 수집하는 데 많은 시간이나 노력을 들일 필요가 없다.
  - 즉, 이해하기 쉬운 코드라는 뜻
- 반대로 코드가 명확하지 않으면 독자는 많은 시간과 에너지를 소비해야하고 이것은 효율성을 감소시킬 뿐만 아니라 오해와 버그의 가능성도 증가시킨다.
  - 즉, 변경이 어려워진다.
- 그렇지만 명확하다의 기준은 독자의 마음에 달려있다.
  - 따라서 자신의 코드에서 문제를 보는 것보다 다른 사람의 코드가 명확한지를 판단하는 것이 더 쉽다
  - 여기에 가장 좋은 방법은 코드 리뷰이다.
  - **누군가 당신의 코드를 보고 명확하지 않다고 말한다면 아무리 당신에게 명확하게 보일지라도 그 코드는 명확하지 않은 것이다.**
- 코드를 명확하지 않게 만든 이유를 이해하려고 노력해서 명확하지 않게 만드는 이유들을 피하고 더 나은 코드를 작성하는 방법을 배워라

## 코드를 명확하게 만드는 것들

**코드를 명확하게 만드는 것들은 다음과 같다.**

- `좋은 이름을 선택하는 것`
  - 정확하고 의미있는 이름은 코드의 동작을 명확히 하고, 문서의 필요성을 해결한다.
  - 이름이 모호한 경우 독자는 해당 엔티티의 의미를 추론하기 위해 코드를 읽어야하고 이는 많은 시간을 할애하며 오류가 발생하기 쉽다
- `일관성`
  - 일관성이 보장되면 신뢰도가 오른다. 즉, 명확해진다.
  - 비슷한 일이 항상 비슷한 방식으로 이루어지면 독자는 이전에 본 패턴을 인식하고 코드를 자세히 분석하지 않고도 즉시 안전한 결론은 도출할 수 있다.
- 때로는 명확하지 않은 코드를 피할 수 없는 경우도 있는데, 이 경우 주석을 활용하자
  - 독자의 입장이 되어 무엇이 독자를 혼란스럽게 할 수 있는지, 그리고 어떤 정보가 그 혼란을 해소할 수 있는지 파악해야 한다.
  - 코드는 독자가 기대하는 규칙을 준수할 때 가장 분명하다.
  - 그렇지 않은 경우 독자가 혼동하지 않도록 동작을 문서화하는 것이 중요하다.

- 개인적으로 golang의 sort.SliceStable()이라는 함수가 파라미터 값을 봤을 때는 모호하다고 생각하는데 주석으로 문서화를 잘 해두어서 이 모호함을 해결한 케이스라고 생각한다.
  - `func SliceStable(x any, less func(i int, j int) bool)` 여기서 매개변수 명만 보면 대체 less 함수에서 어떤 값을 return해야 앞으로 정렬되는 거지? 라는 의문점이 생긴다.
  - 이럴 때면 IDE에서 해당 함수를 자세히 들여다보는데 다음과 같이 예시가 주석으로 포함되어 있다.
  - 이런 경우 이 주석을 통해 빠르게 이해한 경험이 몇 번 있다.

```go
people := []struct {
  Name string
  Age  int
 }{
  {"Alice", 25},
  {"Elizabeth", 75},
  {"Alice", 75},
  {"Bob", 75},
  {"Alice", 75},
  {"Bob", 25},
  {"Colin", 25},
  {"Elizabeth", 25},
 }

 // Sort by name, preserving original order
 sort.SliceStable(people, func(i, j int) bool { return people[i].Name < people[j].Name })
 fmt.Println("By name:", people)

 // Sort by age preserving name order
 sort.SliceStable(people, func(i, j int) bool { return people[i].Age < people[j].Age })
 fmt.Println("By age,name:", people)

 //Output:
 //By name: [{Alice 25} {Alice 75} {Alice 75} {Bob 75} {Bob 25} {Colin 25} {Elizabeth 75} {Elizabeth 25}]
 //By age,name: [{Alice 25} {Bob 25} {Colin 25} {Elizabeth 25} {Alice 75} {Alice 75} {Bob 75} {Elizabeth 75}]
```

## Red Flag: Nonobvious Code

- 빠른 읽기로 코드의 의미와 동작을 이해할 수 없다면 위험 신호 Red Flag!
- 종종 이는 코드를 읽을 때 즉각적으로 명확하지 않게 느껴지는 중요한 정보가 있음을 의미한다.

## 결론

- **코드를 명확하게 만들려면 독자가 코드를 이해하는 데 필요한 정보를 항상 가지고 있는지 확인해야 한다.**
- **다음 세 가지 방법으로 이를 수행할 수 있다.**
  - `추상화`와 같은 설계 기술을 사용하고 `특수한 경우를 제거`하여 `필요한 정보의 양을 줄인다`.
  - 독자가 다른 컨텍스트에서 이미 획득한 정보를 활용하여 `독자가 코드에 대한 새로운 정보를 배울 필요가 없게 한다`.
    - e.g. spring-data-jpa의 조건문 컨벤션
  - `좋은 이름` 및 `전략적 설명`과 같은 기술을 사용하여 코드에서 중요한 정보를 제공한다.

# 19. Software Trends

- 트랜드에 따라 소프트웨어 복잡성에 대한 영향력을 제공하는지 알아보자

## 객체지향 프로그래밍과 상속

OOP(객체지향 프로그래밍)의 핵심 요소 중 하나인 `상속`과 연관된 소프트웨어 복잡성에 대해 살펴보자

- 상속은 소프트웨어 복잡성에 대해 서로 다른 의미를 갖는 다음 두 가지 형태로 제공된다.
- `인터페이스 상속`
  - 인터페이스 상속은 동일한 인터페이스를 여러 용도로 재사용함으로써 복잡성을 방지할 수 있음.
- `구현 상속`
  - 클래스를 상속하는 `구현 상속`은 시스템이 발전함에 따라 수정해야 하는 코드의 양을 줄여줄 수도 있지만
  - 부모 클래스와 하위 클래스 간에 종속성을 생성하고 이는 결국 코드 변경을 어렵게 만든다
- OOP에서 제공하는 메커니즘은 깔끔한 디자인을 구현하는 데 도움이 될 수 있지만 그 자체로 좋은 디자인을 보장하지는 않는다.

## 애자일 개발

이 책에서 말하는 좋은 설계를 완성하는 가장 좋은 방법은 애자일 개발 접근 방식과 유사하다.

- 프로젝트 초기에 복잡한 시스템을 충분히 잘 시각화하여 최적의 디자인을 결정하는 것은 불가능하고
- 결국 좋은 설계를 완성하는 가장 좋은 방법은 시스템을 점진적으로 개발하는 것이며, 이 과정에서 몇 가지 새로운 추상화를 추가하고 경험을 바탕으로 기존 추상화를 리팩터링하는 것이다.
- 이는 애자일 개발 접근 방식과 유사함.
- `애자일 개발의 위험` 중 하나는 전술적 프로그래밍으로 이어질 수 있다는 점이다.
  - 애자일 개발은 개발자가 **추상화가 아닌 기능에 집중**하는 경향이 있으며, 개발자가 **가능한 한 빨리 작동하는 소프트웨어를 생산하기 위해 설계 결정을 미루도록 장려**한다.
  - 그러나 이로 인해 복잡성이 빠르게 누적될 수 있다.
- **점진적으로 개발하는 것은 일반적으로 좋은 생각이다.**
  - **하지만 개발의 증분은 기능이 아닌 추상화여야 한다.**
  - 당연하게도 특정 추상화에 대한 모든 생각은 기능에 필요할 때까지 미루는 것이 좋고 추상화가 필요하면 시간을 투자하여 깔끔하게 디자인하고 어느 정도 범용적으로 만들어두는 것이 좋다.

## 단위 테스트

- 테스트 코드 작성하라
- 테스트 코드가 없으면 리팩터링 하기 어렵다.
- 결과적으로 좋은 테스트 코드가 없는 시스템에서는 리팩터링을 피하고 새로운 기능이나 버그 수정 시마다 코드 변경 횟수를 최소화하려고 하기 때문에 복잡성이 누적되고 설계 실수가 수정되지 않는다.
- 리팩터링에 자신감을 주는 좋은 테스트 코드를 작성하라

## 테스트 주도 개발 - TDD

- 테스트 중심 개발의 문제점은 최상의 디자인을 찾는 것이 아니라 특정 기능을 작동시키는 데 집중한다는 것이다.
  - 이건 모든 단점을 가진 순수하고 단순한 전술적 프로그래밍이다.
  - TDD는 너무 점진적이고 어느 시점에서든 다음 테스트를 통과하기 위해 다음 기능을 해킹하고 싶은 유혹에 빠질 수 있다.
  - 결국 TDD는 이런 면에서 설계를 할 시간이 명확하지 않기 때문에 엉망으로 끝나기 쉽다.
- **개발 단위는 기능이 아닌 추상화여야 한다.**
  - 추상화의 필요성을 발견하면 추상화를 시간이 지남에 따라 조각조각 만들지 말고 시간을 써서 한 번에 설계하라.
  - 이렇게 하는 것이 조각들이 서로 잘 어울리는 깔끔한 디자인이 만들어질 가능성이 더 높다.

## 디자인 패턴

- 디자인 패턴은 특정 상황에서 잘 작동한다면 더 나은 다른 접근 방식을 생각해 내기 어려울 정도로 강력하다.
  - 하지만 과도하게 적용하면 복잡도만 올라간다.
  - 모든 문제를 기존 디자인 패턴으로 깔끔하게 해결할 수 있는 것은 아니다.
- **디자인 패턴이 좋다는 개념이 반드시 디자인 패턴이 많을수록 좋다는 것을 의미하지는 않는다**

## Getter와 Setter

- **인스턴스 변수를 노출해야 하는 경우 게터와 세터를 사용하는 것이 합리적일 수 있지만, 애초에 인스턴스 변수를 노출하지 않는 것이 좋다.**
  - 인스턴스 변수가 노출되면 정보 은닉 개념에 위배되고 클래스 인터페이스의 복잡성을 증가시킨다.
  - 게터와 세터는 얕은 메서드이기 때문에 많은 기능을 제공하지 않고 클래스 인터페이스의 복잡성을 증가시킨다.
  - 따라서 가급적 게터와 세터 또는 구현 데이터의 노출을 피하는 것이 좋다.
- **디자인 패턴을 설정할 때 위험 중 하나는 개발자가 패턴이 좋다고 생각하고 가능한 한 많이 사용하려고 한다는 것이다.**
  - 이로 인해 Java에서 게터와 세터가 과도하게 사용되었다.

## 결론

- 여러 패러다임을 접할 때마다 정말 이 패러다임이 소프트웨어 시스템의 복잡성을 최소화하는 데 도움이 될지는 좀 더 깊이 들여다보면 복잡성을 오히려 악화시키는 제안일 수 있으니 항상 주의하자

# 20. Designing for Performance

- 고성능과 깔끔한 디자인은 양립할 수 있다.
- 복잡한 코드는 불필요한 작업이나 중복 작업을 수행하기 때문에 속도가 느린 경향이 있음
- 반면 깔끔하고 간단한 코드를 작성하면 시스템이 충분히 빨라져 성능에 대해 크게 걱정하지 않아도 된다.
- 성능을 최적화해야 하는 몇가지 경우에서 핵심은 다시 단순성이다.
- 성능에 가장 중요한 포인트를 측정을 통해 찾고 가능한 한 단순하게 만들어라.

