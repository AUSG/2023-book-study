# 9. 창조자의 심미적 취향

-   아름다운 것을 인식하려면, 그것을 인식할 수 있는 능력을 갖춰야한다. 좋은 작품을 만드는 데 필요한 자기만의 미적 취향을 가지고 있어야 한다.

-   성장했다면 과거의 미적 취향은 단지 현재의 것과 달랐던 게 아니라 덜 성숙한 것이였던 셈이다. 여러 분야의 생각이 얼마나 많이 공통 되는지 놀라게 된다. 좋은 디자인과 같은 원리가 끊임없이 반복되어 적용되고 있는 것이다.

-   위대한 작품을 만드는 방법은 바로 자기 자신만의 미적 취향과 그것을 만족하게 할 수 있는 능력에 달려 있는 것이다.

    


# 10. 프로그래밍 언어에 대한 설명

-   기계어는 어떤 일을 하기 위해 더 많은 이야기를 해야 할수록 버그를 피하는 것은 점점 더 어려워진다.
-   고수준 언어는 에러를 발견하기 쉽고, 프로그램의 이식 가능성을 높여준다.
-   나는 소유권에 반대하지 않지만, 소스코드가 공개되지 않은 SW를 설치하는 것을 몹시 꺼리는 사람이다. 당신이 진정한 안정성을 원한다면, 그것이 오픈소스를 지지하는 정당한 공학적 이유가 된다.
-   고수준 언어는 추상화를 통해 사람에 가까워지며 프로그래밍의 효율성을 제공하고, 저수준 언어는 하드웨어에 가까워지며 성능의 효율성을 제공한다.
-   언어 설계에서 가장 큰 논쟁은 멍청한 실수를 저지르는 것을 막아야 한다고 생각하는 쪽과 원하는 것은 무엇이든 할 수 있도록 허용해야 한다고 생각하는 쪽 사이의 논쟁이다. 자바는 앞에 속하고, 펄은 뒤에 속한다. 정적 타이핑, 동적 타이핑도 마찬가지 이다.

// todo: 여기서부터!

# 11. 100년 후의 프로그래밍 언어

-   프로그래밍 언어는 생명의 종과 마찬가지로 사방에 막다른 길이 있는 진화의 가지를 그려 나갈 것이다. 우리는 진화가 전개되는 상황을 이미 목격하고 있다. 한때 유명했던 코볼은 이제 어떠한 지적인 후손도 갖지 못하고 있다. 진화의 최종 단계에 다다른 것이다. 코볼은 네안데르탈인 언어와 같은 운명을 맞이하고 있다. 
-   코볼이 그랬던 것처럼, 결국 자바도 진화의 과정에서 언젠가 막다른 길에 이르게 될 것이다.
-   나무의 잔가지가 아니라 줄기에 가까이 가는 것이 당장 프로그래밍하기 좋은 언어를 선택하는 데 도움이 되기 때문이다.
-   100년 후의 언어에 대해서 알고자 하는 이유는 지금 나무의 줄기에 해당하는 언어가 무엇인지 알아보기 위해서이다.
-   언어 자체는 테크놀로지가 아니기 때문에 천천히 발전한다. 언어는 표기다. 따라서 프로그래밍 언어의 발전 속도는 수학적 표기 방법의 발전 속도와 비슷하다. 수학적 표기 방법도 발전하기는 하지만, 테크놀로지만큼은 아니다.
-   100년 후의 빠른 하드웨어가 우리에게 제공해 줄 추가 사이클은 대부분 낭비될 것이다.
-   세상에는 좋은 낭비와 나쁜 낭비가 있다. 나는 더 많이 소모함으로써 더 단순한 디자인을 얻을 수 있는 좋은 낭비에 관심이 있다.
-   빌 우즈는 언젠가 나에게 해석이 필요한 층이 하나 존재할 때마다 열 배에 달하는 속도 손실이 나타난다고 말한 적이 있다. 이러한 희생을 감내하고 유연성을 얻는 것이다.



# 12. 평균 뛰어넘기

-   리스프는 그것을 마침내 손에 넣게 되었을 때 경험하게 되는 심오한 깨달음을 위해서라도 배울 가치가 있다. 리스프를 이용할 일이 그렇게 많지 않다고 할지라도 그 경험은 그 자체만으로 당신을 훨씬 훌륭한 프로그래머로 만들어줄 것이다.
-   다른 사람들이 그것을 이용하지 않는 이유는 프로그래밍 언어라는 것이 단순한 테크놀로지가 아니라 습관이기 때문이다.



# 13. 공부벌레의 역습

-   1950년대에 탄생한 이 언어가 오늘날에도 여전히 유효한 이유는, 그것이 단순한 테크놀로지가 아니라 수학이었다는 사실이다.
-   스타트업을 시작한다면, 벤처 투자자나 잠정적 구매자를 기쁘게 할 목적으로 제품을 만들지 말아야 한다. 오직 사용자를 기쁘게 만들기 위해서 제품을 만들어야 한다. 사용자를 얻게 되면 나머지는 저절로 따라온다. 사용자를 얻지 못하면, 당신이 선택한 기술적인 내용들이 아무리 정통 표준을 따르고 있다고 해도 관ㅅ미을 갖는 사람은 아무도 없을 것이다.
-   충분히 복잡한 C나 포트란 프로그램은 비공식적으로 정의된 버그투성이의 느린 커먼 리스프의 절반을 담고 있다.
-   핵심은 1. 강력한 언어를 사용하고 2. 그것을 위한 사실상의 인터프리터를 작성할 것인가, 아니면 3. 당신 자신이 그 언어를 위한 인간 컴파일러가 될 것인가 하는 것이다.
-   프로그램의 패턴을 발견하면 그것을 뭔가 문제가 발생하고 있다는 신호로 받아들인다. 프로그램의 형태는 오직 그것이 해결해야 하는 문제만 반영해야 한다. 



# 14. 꿈의 언어

-   오늘날의 지배적인 테크놀로지를 둘러보면, 그들이 모두 유기적인 성장 과정을 거쳤음을 알게 될 것이다. 멀틱스나 에이다는 빅뱅 프로젝트였고, 유닉스와 C는 유기적인 성장 프로젝트였다.

-   가장 좋은 글쓰기는 다시 쓰는 것이다.

-   모듈이 추상화의 층에서 수직으로 쌓이도록 만드는 것이다. 이렇게 하면 인터페이스는 그중 어느 하나에 의해서 결정된다. 이러헥 하면 인터페이스는 그중 어느 하나에 의해서 결정된다.

-   그 언어는 추상화를 당신에게 이러저러한 일을 해야 한다고 알려주기 위해서가 아니라 오로지 당신의 일을 절약해 주기 위한 목적으로만 제공한다.


# 15. 디자인과 연구

-   사용자를 위에서 내려다보게 되면, 그것이 아무리 선량한 의도에서라도 설계자의 작업을 망치기 쉽다.
-   언어라는 것이 완성된 프로그램을 위한 형식이 아니라, 프로그램 자체가 그 언어를 이용해서 사고하고 개발된다는 점을 기억할 필요가 있다.
-   유화가 15세기에 유명해졌을 때 그것을 그렇게 대단한 존재로 만든 것은 완성된 작품을 프로토타입으로 바꿀 수가 있다는 점이었다.
-   화가가 작품을 완성하는 경우는 없다. 단지 그는 작업을 멈출 뿐이다.
