# 09~15

# 09. 창조자의 심미적 취향

> **위대한 디자인에 이르는 길**
>

## 좋은 디자인은 간단하다

- 수학에선 짧은 증명일 수록 훌륭하다는 의미로 해석되고
- 공리는 특히 짧으면서 많은 의미를 함축한 그 무엇에 집중한다
  - 공리: **하나의 이론에서 증명 없이 바르다고 하는 명제**
- **프로그래밍에서도 마찬가지다.**
- 글쓰기에서는 필요한 말을 짧고 명료하게 등..
- **진정한 문제는 단순성이 강제되었을 때 만나게 된다. 무의미한 장식물을 동원할 수 없게 되었을 때에는, 실질적인 내용을 보여주어야 하기 때문이다.**
  - 생각) 이력서에 있는 회사도 비슷한 느낌인 것 같다. 허물을 벗겼을 때의 본질.

## 좋은 디자인은 시간에 구애받지 않는다

- 미래에도 여전히 멋지게 보일 만한 것을 만들고 싶다면 순간적인 유행이 아니라 사물의 고유한 장점으로부터 내용을 이끌어 내야 한다.
- 좀 이상하게 들릴 수 있지만, 미래의 세대에게 통하는 어떤 것을 만들고 싶다면 이전 세대에게도 통할 만한 것을 만들어야 한다.
  - 유행은 돌고 돈다.

## 좋은 디자인은 제대로 된 문제를 해결한다

- 나쁜 디자인은 대개 방향이 틀릴 때 나온다.
  - e.g. 버너 모양과 다르게 배치된 다이얼, 미적 외관을 선택하고 가독성을 포기한 폰트
- 해결책과 마찬가지로 문제 자체도 개선할 수 있다.
  - 소프트웨어 세계에서는 해결하기 어려운 문제를 그보다 더 쉬운 문제로 대체하는 일이 흔히 있다.

## 좋은 디자인은 무언가를 제안한다

- 좋은 건물은 사람들이 그 안에서 건축가의 각본을 수행하는 배우로서의 삶을 살도록 강요하지 않는다. 오히려 공간의 기초 위에 자유를 제공할뿐.
- 이 말을 확장하면 소프트웨어는 사용자들에게 레고와 같이 원하는 것을 스스로 만들 수 있도록 기본적인 요소를 제공해야 함을 의미한다.
  - 수학에서는 새로운 연구에 영감을 제공하지 못하는 증명보다 새로운 연구의 기초가 되는 증명이 더 낫다.
  - 과학에서는 다른 이론이나 논문에서 얼마나 인용되는가가 연구 가치를 측정하는 척도다.

## 항상 그런 것은 아니지만 좋은 디자인은 조금 우습기도 하다

- 하지만 적어도 사리넨의 자궁 의자, 포르셰 911을 보면 재미있따.
  - 플로렌스 놀은 사리넨에게 '내가 앉고 싶은 대로 옆이나 다른 방향으로도 앉을 수 있는 의자'를 디자인해달라고 요청했다. 사리넨은 수많은 사람들이 자궁을 떠난 뒤 결코 안락함과 안전함을 느끼지 못했다는 이론에 근거해 이 「Womb Chair」 즉 '자궁 의자'를 디자인했다.
- 유머감각을 유지한다는 것은 불행을 가볍게 털어내고 반대로 유머감각을 상실한다면 불행에 압도된다.
- 좋은 디자인이 꼭 우스워 보일 필요는 없다. 하지만 유머가 없는데 좋은 디자인으로 불리는 것을 상상하기가 쉽지는 않다.

## 좋은 디자인은 어렵다

- 위대한 작품을 탄생시킨 사람들이 가진 공통점은 그들이 엄청난 노력을 기울였다는 사실이다.
  - 당신이 지금 엄청난 노력을 기울이고 있지 않다면, 스스로 시간을 낭비하고 있는 것이다.
- 물론 어렵다고 해서 좋은 것은 아니다. 고통에는 좋은 것과 나쁜 것이 있다.
  - 어려운 문제에 부딪힘으로써 디자이너는 더욱 발전하지만,
    여기에서 어려운 문제라는 것은 변덕스러운 고객이나 품질이 떨어지는 옷감 따위는 아니다.-
  - 생각) 어려운 문제를 쉬운 문제로 바꾸거나 쉽게 풀어내는 것이 좋다고 생각한다.

## 좋은 디자인은 간단해 보인다

- 위대한 운동 선수와 마찬가지로 위대한 디자이너는 작품을 쉽게 볼 수 있도록 만든다.
  - 그렇지만 이것은 대부분 환상이다.
  - 좋은 글에서 등장하는 쉬운 대화체 문장은 여덟 번은 고쳐야 나올 수 있는 문장이다.
  - 이런 것들은 대부분 “나도 생각할 수 있었을 텐데”하고 생각할 정도로 단순하다.
    - 그리고 이 질문을 한다면 생각이 달라질 것이다.
        **“하지만 당신은 왜 그렇게 생각하지 않았습니까?”**

## 좋은 디자인은 대칭을 이용한다

- 대칭은 그저 단순성을 담보하기 위한 방법 중 하나로 보이지만, 따로 언급할 필요가 있을 정도로 중요하다.
- 대칭에는 두 가지 종류가 있다. 반복과 재귀.

## 좋은 디자인은 자연을 닮았다

- 자연은 이미 오랜 세월 동안 문제를 해결하기 위해서 노력해 왔기 때문에 자연을 닮은 것은 본질적으로 좋다.
- 어떤 답이 자연을 닮았다면 그것은 항상 좋은 신호다.
  - e.g. 유전자 알고리즘

## 좋은 디자인은 무언가를 다시 디자인하는 것이다

- 무엇이든 맨 처음에 제대로 만들어 내기는 어려운 법이다.
- 전문가들은 처음에 만든 작품은 내다 버리게 될 것이라고 생각한다.
- 그들은 항상 변화를 염두에 둔다.
- 실수는 자연스러운 것이다.
  - 그것을 재난으로 간주하는 대신, 실수를 쉽게 인정하고 쉽게 고칠 수 있도록 허용해야 한다.
- 오픈소스 소프트웨어는 버그의 가능성을 솔직하게 인정하기 때문에 실제로 훨씬 적은 버그를 포함하고 있다.

## 좋은 디자인은 복사가 가능하다

- 초보자는 자기가 복사를 하고 있다는 사실을 깨닫지 못한채 흉내를 낸다.
  - 그 다음 단계에서는 의식적으로 원작을 모방한다.
  - 마지막 단계에서는 원작을 복사하는 것보다는 스스로 제대로 된 작품을 만드는 것이 더 중요하다는 사실을 깨닫는다.
  - 자기가 무얼 하는지도 모르고 따라 하기만 하는 것은 형편없는 디자인을 만드는 지름길이다.
  - 자기 아이디어가 어디에 근거를 두고 있는 것인지 모른다면, 모조품을 만들고 있는 것이다.
- 미적 취향이 성장하는 두 번째 단계에서는 자신만의 독창적인 작품을 만들기 위해서 의식적으로 노력하게 된다.
  - 위대한 대가는 이기심과 다를 바 없는 자신의 열망을 채우기 위해서 전진하고
  - 그들은 단지 올바른 대답을 구하길 원하며 그 올바른 대답의 일부가 다른 사람에 의해 이미 발견되었다면 그 방법을 사용하지 않을 이유가 없다고 생각한다.
  - 그들은 다른 사람의 생각을 도용한다고 해서 자기 자신의 관점이 상실되는 것은 아니라고 확신한다.
- **스스로 생각하고 자기 자신의 관점을 가져라**

## 좋은 디자인은 이상할 때도 있다

- 가장 훌륭한 작품은 어딘가 기이한 부분이 있다.
  - e.g. 오일러의 공식, 리스프 등
  - 아인슈타인은 상대성 이론을 일부러 이상하게 만들려고 노력하지 않았고, 그는 진실을 있는 그대로 드러내려고 노력했을 뿐이며, 진실 자체가 우리에게 이상하게 보였을 뿐이다.

## 좋은 디자인은 뛰어난 사람들의 모임에서 나온다

- 재능 있는 사람이 모여서 관련된 문제를 연구하는 커뮤니티보다 강력한 것은 없다.

## 좋은 디자인은 종종 대담하다

- 오늘날의 실험적 오류는 내일의 새로운 이론을 위한 밑거름이 된다.
  - 새롭고 위대한 무언가를 발견하고자 한다면, 전통적인 지혜와 진실이 서로 어긋나는 상황을 좌시하기보다는 그런 곳에 시선을 집중해야 한다.
- **아름다움을 상상하는 것보다 추함을 지켜보는 것이 쉽다.**
  - 그리고 아름다운 것을 창조한 사람들은 자기 눈에 추하게 보이는 것을 고치는 과정을 거쳤다.
  - 위대한 작품은 누군가 어떤 것을 바라보고 생각을 하기 때문에 탄생한다.
    - e.g. “흠, 나라면 저거보다 더 잘 만들 수 있을텐데…”
  - 추함을 참지마라.
- 추함을 참을 수 없는 것만으로는 부족하다.
  - **좋은 후각을 발달시키기 전에 해당 분야의 일을 충분히 이해하고 있어야 한다.**
    - 즉, 창조 이전에 자기 숙제부터 해야 하는 것이다.
  - 어떤 분야의 전문가로 성장함에 따라서, “이것보다 더 나은 방법이 있을 거야”라는 희미한 목소리를 듣게 될 것이다.
  - **그 목소리를 무시하지 않기 바란다.**
    - 위대한 작품을 만드는 방법은 바로 자기 자신만의 미적 취향과 그것을 만족하게 할 수 있는 능력에 달려 있는 것이다.

# 10. 프로그래밍 언어에 대한 설명

- **기계어, 고수준 언어, 오픈소스가 무엇인지 등 이야기함**

## 언어의 전쟁

- **수많은 프로그래밍 언어 중에서 어느 것을 사용해야 하는가?**
  - 이 질문에는 수많은 대답이 존재한다.
- 문제인 것은 어떤 언어를 오랫동안 사용하면, 어느 순간부터 사고 자체가 그 언어로 이루어진다는 사실이다.
  - 이런 상황이 되면 실질적으로 다른 언어에 본질적으로는 잘못된 것이 아무것도 없음에도 불구하고, 터무니없이 어색하게 느껴진다.
  - 경험이 부족한 프로그래머들이 언어에 대해서 내리는 판단은 이러한 심리적 효과에 영향을 받기도 한다.
- 뭔가 그럴듯하게 보이고 싶은 욕망 때문에 어떤 해커는 모든 언어는 결국 다 같은 것이라고 말할지도 모른다.
  - 그런데 이건 넌센스다. 각 언어는 분명 다르다.
  - 만약 당신이 맥도날드에서만 음식을 먹어 봤다면 전 세계의 음식이 모두 똑같아 보일 것이다.
- 해커 중 일부는 이미 익숙해진 언어만을 선호하고, 그 밖의 모든 것을 혐오한다.
  - 반면 일부는 세상에 존재하는 언어가 모두 똑같은 것이라고 말한다.
- **언어는 서로 다르지만, 사실무엇이 최선인지에 대해서 말하는 것은 쉽지 않다.**
  - 이것은 프로그래밍이라는 분야는 계속해서 발전하고 있기 때문이다.

## 안전벨트 혹은 수갑?

- 언어 설계에서 가장 큰 논쟁은 아마도 이것이다
  - 멍청한 실수를 저지르는 것을 막아야 한다
    vs
    원하는 것은 무엇이든 할 수 있도록 허용해야 한다
  - 자바는 앞에 속하고, 펄은 뒤에 속한다
  - 미국 국방부에서 자바의 손을 들어주는 것은 놀라운 일이 아니다
- 보통 정적/동적 타이핑을 가지고 이야기를 하는데, 결국 이 질문은 아직 정답이 없는 상태로 남아 있다.

# 11. 100년 후의 프로그래밍 언어

- 프로그래밍 언어는 생명의 종과 마찬가지로 사방에 막다른 길이 있는 진화의 가지를 그려 나갈 것이다.
- 결국 자바도 진화의 과정에서 언젠가 막다른 길에 이르게 될 것이다. 코볼이 그랬던 것처럼. 하지만 이것은 단지 추측에 불과하다.
- 이 진화의 줄기에 가까이 가는 것이 당장 프로그래밍하기 좋은 언어를 선택하는데 도움이 된다.
  - 프로그래밍 언어의 진화가 어디를 향하고 있는지를 생각해 보는 것은 언어의 설계자들에게 특히 유용하다.
  - 그들이야말로 그 방향을 향해서 나아갈 수 있는 사람들이고 이 경우 “줄기에 서 있는 것”은 단순히 좋은 언어를 선택하는 것 이상으로 언어의 설계에 있어서 올바른 결정을 내리기 위한 경험적 규칙이 된다.
- 모든 프로그래밍 언어는 두 개의 부분으로 나뉜다
  - 공리의 역할을 담당하는 기본 연산자 집합
  - 이 연산자를 이용해서 작성할 수 있는 언어의 나머지 부분
- 기본 연산자는 그 언어의 장기적인 사활에 가장 중요하다.
  - 공리를 잘 선택하는 것만으로는 부족하고, 수도 적어야 한다.
  - 수학자들은 공리가 적을수록 좋다고 생각해 왔다.
- 어떤 언어의 중심을 깊게 들여다보면서 없어도 좋은 공리가 있는지 살펴보는 것은 좋은 연습이 된다.
- 언어의 진화 나무의 중심 줄기는 가장 작고 깔끔한 중심부를 가지고 있는 언어를 관통할 것이다. 그 안에서 프로그램을 많이 작성할 수 있을수록 더 좋은 언어이기 때문이다.
- 100년 뒤 비효율의 기준은 무엇이 될까?
  - 하드웨어의 성능은 점점 좋아질 것이고
  - 오히려 프로그래머의 시간을 낭비하는 것이 진짜 비효율성일 것이다.

# 12. 평균 뛰어넘기

> **나를 알고, 경쟁자를 살핀다**
>
- 에릭 레이몬드의 [어떻게 해커가 되는가(How to Become a Hacker)]라는 에세이에서 해커가 되고 싶은 사람이 배워야 하는 언어에 대해 설명한다.
  - 배우기 쉽다는 점을 이유로 파이썬과 자바
  - 심각한 해커라면 유닉스를 해킹하기 위해서 C
  - 그리고 시스템 관리와 CGI 스크립트를 위해서는 펄
  - 하지만 진짜 심각한 해커는 **리스프**

> 리스프는 그것을 마침내 손에 넣게 되었을 때 경험하게 되는 심오한 깨달음을 위해서라도 배울 가치가 있다.
리스프를 이용할 일이 그렇게 많지 않다고 할지라도 그 경험은 그 자체만으로도 당신을 훨씬 훌륭한 프로그래머로 만들어줄 것이다.
>

### 블럽의 역설

- 리스프가 대단한 이유는 리스프가 가장 강력한 언어이기 때문이다.
- 다른 사람들이 그것을 이용하지 않는 이유는 프로그래밍 언어라는 것이 단순히 기술이 아니라 `습관`이기 때문이다.
- 이 세상에서 습관처럼 천천히 변하는 것은 없다.
- **여러 개의 언어 중에서 하나만 선택할 수 있는 상황에서, 다른 조건이 모두 같다면, 기능적 힘이 가장 뛰어난 언어가 아닌 다른 것을 선택하는 것은 실수이다.**
  - 이 규칙엔 많은 예외가 있고 보통 그 상황에 맞는 환경적인 요소이다.
- 기능이 풍부한 언어를 사용하던 프로그래머가 기능이 부족한 언어를 내려다보는 동안에는 그 사람은 본인이 내려다보고 있는 사실을 안다.
  - 이미 익숙했던 기능들이 없으니 역체감을 느끼는 건 당연하다.
  - 하지만 반대의 경우 그저 기묘한 언어로 보일 것이다. 그리고 지금 쓰는 언어가 충분히 훌륭하다고 느낄 것이다. 지금 쓰는 언어를 기준으로 사고하기 때문에.

- 당신이 스타트업을 위해 일하고 있다면 경쟁자를 판단하는 간단한 방법이 있다.
  - 바로 그들의 구인 광고인데, 일자리를 설명하는 문구에서 IT와 관련된 냄새가 더 많이 날수록, 별로 염려할 필요가 없는 회사였다.
  - 오라클 경험, C++나 자바 개발자 등. 하지만 펄이나 파이썬 프로그래머를 찾는 경우에는 약간 긴장할 필요가 있다.
  - 그것은 회사가 최소한 기술적인 부서는 해커에 의해서 운영된다는 증거이기 때문이다. 만약 내가 리스프 해커를 찾는 구인 공고를 보았다면, 진짜 걱정하기 시작했을 것이다.

# 13. 공부벌레의 역습

> **망하는 지름길, 최고 사례 따라하기**
>
- 자바, 펄, 파이썬, 루비 순서로 보면 점점 리스프를 닮아가고 있다.
  - 최소한 리스프 해커라면 이 패턴을 발견할 수 있을 것이다.
  - 리스프가 1958년에 존 매카시에 의해서 처음으로 발견되었는데, 오늘날의 유명한 언어들은 그가 당시에 고안한 생각을 겨우 따라잡기 시작했다는 이야기이다.
  - 이 이야기가 유효한 이유는 리스프틑 단순히 기술이 아니라 수학이었다는 사실이다.
    - **수학은 변질되지 않는다.**

### 리스프의 특징

- 처음 개발되었을 때 리스프는 아홉 개의 새로운 아이디어를 구현하고 있었다.
- 이들 중에서 어떤 것은 이제 당연한 사실로 받아들여지고 그럼에도 어느 것은 가장 최근의 발전된 언어에서만 발견되며, 이 중 두 개는 아직 리스프에만 존재한다.
- 아홉 개의 아이디어를 메인스트림에 의해서 받아들여진 순서대로 나열해 보면 다음과 같다.
  - `조건문(conditionals)`
  - `함수의 타입(function type)`
  - `재귀(recursion)`
  - `동적 타이핑(dynamic typing)`
  - `가비지 컬렉션(garbage collection)`
  - `표현으로 이루어진 프로그램`
    - 리스프 프로그램은 각자 하나의 값을 리턴하는 여러 개의 표현으로 구성된 트리이다.
  - `심볼 타입(symbol type)`
    - 심볼 = 실질적으로 해시 테이블 안에 저장된 문자열을 가리키는 포인터
    - 즉, 포인터만 비교해서 그들이 동일한지 여부 파악
  - `심볼과 상수의 트리를 이용하는 코드를 위한 표기 방식(notation)`
  - `언어 전체를 계속 사용할 수 있음`
    - 리스프에서는 읽는 시간, 컴파일하는 시간, 그리고 실행 식나에 대한 진정한 구분이 없다. 코드를 읽는 동안 컴파일이나 실행이 가능하고 컴파일하는 동안 읽거나 실행이 가능하다는 말이다.
    - 즉, 실행 시간에 코드를 읽거나 컴파일하는 것도 가능하다

### 구심력

- 흔하지 않은 기술을 사용하는 데 따르는 비용이 전혀 없다고 주장하는 것은 아니다.
  - 대부분의 뾰족머리(?) 보스가 이런 부분을 걱정하는 것이 전적으로 잘못되었다고 할 수 없다.
  - 하지만 그는 위험의 본질을 제대로 이해하지 못하고 있기 때문에 위험의 크기를 과장하는 경향이 있다.
- 덜 유명한 언어를 사용할 때 문제는 무엇일까?
  - `다른 언어로 작성된 프로그램과의 호환성`
  - `사용할 수 있는 라이브러리의 제한`
  - `프로그래머 고용`
- 그런데 이건 도대체 얼마나 큰 문제일까?
  - `다른 언어로 작성된 프로그램과의 호환성`
    - 이건 당신이 시스템 전체를 통제할 수 있는가? 이다. 통제력을 가지고 있다면 원하는 대로 하면 된다.
  - `사용할 수 있는 라이브러리의 제한`
    - 라이브러리의 중요성은 애플리케이션에 달려있다.
    - 손익분기점은 어디인가?
      - 간단한 문제는 라이브러리의 존재가 언어 자체의 고유한 기능보다 더 큰 의미를 가질 수 있다.
      - 하지만 최소한 몇 명의 해커와 6개월 정도의 시간을 요구하는 큰 규모의 프로젝트라면 강력한 언어의 기능이 미리 존재하는 라이브러리의 편리함을 앞지르기 시작할 것이다.
  - **`프로그래머 고용`**
    - 당신이 고용해야 하는 해커가 결국 몇 명이나 되겠는가?
    - 우리는 이제 최고의 소프트웨어는 열 명 이하의 사람으로 이루어진 팀에 의해서 만들어질 수 있다는 사실을 분명히 알게 되었다.
    - 리스프 해커 열 명을 찾을 수 없다면 아마도 당신의 회사는 소프트웨어 개발에 어울리지 않는 도시에 자리 잡은 것일 것이다.
    - 사실 강력한 언어를 선택하면 당신이 필요로 하는 팀의 크기를 더 줄일 수도 있을 것이다.
      - 왜나하면 강력한 언어를 사용하면 많은 해커가 필요하지 않기 때문이고
      - 앞선 언어를 사용하는 해커들은 대개 똑똑하기 때문이다.

- **어려운 문제를 해결하고자 한다면, 충분히 강력한 언어를 사용할 것인가 하는 것이 질문의 핵심이 아니다.**
- 핵심은 강력한 언어를 사용하고,
  - 그것을 위한 사실상의 인터프리터를 작성할 것인가?
  - 아니면 당신 자신이 인간 컴파일러가 될 것인가? 하는 것이다.
  - 파이썬를 예시로 class와 `__call__` 함수는 실질적으로 컴파일러가 렉시컬 변수를 생성할 때 만들어냄직한 코드를 흉내 내고 있었던 것이다.
- **이러한 현상은 공통적일 뿐만 아니라 체계적이기까지 하다**
  - 그래서 XX 패턴이라는 말을 흔히 듣게 된다. (e.g. 디자인 패턴 등)
  - 그 패턴들은 사실 인간 컴파일러에 대한 증거가 아닐까 의심스럽다.
  - 저자는 프로그램 안에서 패턴을 발견하면 그것은 뭔가 문제가 발생하는 신호라고 받아들이고 프로그램의 형태는 오직 그것이 해결해야 하는 문제만 반영해야 한다고 생각한다.
    - 코드에 존재하는 그 밖의 모든 정형성은 최소한 저자에게 있어서 내가 충분히 강력하지 않은 추상을 이용하고 있다는 신호로 다가온다.
    - 때로는 간결한 매크로를 작성하는 것이 아니라 매크로가 확장된 형태를 일일이 손으로 작성하고 있는 것이다.
  - 디자인 패턴 23개 패턴 중에 16개는 리스프에서 보이지 않거나 더 간단하다는 사실을 발견했다.

# 14. 꿈의 언어

> **해커들이 마음대로 사용할 수 있다면, 좋은 것이다**
>

- 언어를 유명하게 만드는 것은 무엇일까?
- 유명한 언어들은 정당한 유명세를 얻고 있는 것일까?
- 좋은 프로그래밍 언어를 설계하는 것이 해볼만한 일일까?
- 좋은 언어는 어떻게 만들 수 있는 것일까?
- **이러한 질문에 대한 답은 해커가 진정으로 원하는 것이 무엇인지 알아보면서 얻을 수 있을 것 같다.**
  - 그것은 오직 해커들이 좋아하는 경우에 한해서 좋은 것이기 때문이다.

### 유명세의 메커니즘

- 사람들이 단순히 장점을 기준으로 프로그래밍 언어를 선택하지 않는 것은 사실이다.
- 이는 주로 외부에서 프로그래밍 언어를 추천받기 때문이다
- 많은 프로그래머가 좋은 언어와 나쁜 언어를 재대로 식별하지 못할 수도 있다.
  - 전문적인 해커는 좋은 언어를 보았을 때 바로 알아차리고 사용할 것이다.
  - 하지만 그 정도로 전문적인 해커는 극 소수일 것이다.
- 언어는 일단 유명세를 얻게되면 좋은 건지 나쁜 건지 확실히 분리된다.
  - 실제 사용자들이 제공하는 피드백이 기능의 개선으로 이어지기 때문!
  - 유명한 언어들이 어떻게 변해 왔는지 살펴보기를 바란다.
  - 리스프마저도 수많은 개정을 거칠 수 밖에 없었다.
- 따라서 언어가 유명해지기 위해서 훌륭해야 한다기 보다는 오히려 훌륭해지기 위해서 유명해져야 하는 측면이 있다.
- 온라인 문서 등 외적인 요소도 중요하다.

- 해커들이 좋아하는 언어는?
  - `간결함`
    - 간결함의 가장 중요한 측면은 언어를 더 추상적으로 만든다는 데 있다.
    - 우리가 고수준 언어를 사용하는 이유도 바로 추상 때문이다.
  - `해킹의 가능성(=내가 원하는 걸 할 수 있는가?)`
    - 해커들은 해킹을 좋아한다.
    - `해킹`이란 어떤 존재의 내부에 침투하는 것, 그리고 원래 설계자의 마음을 읽어내는 것을 의미한다.
    - 당신의 마음이 해커들에게 읽히도록 내버려둬라. 당신은 그들이 하는 일을 알 수 없고 그것을 제어하려고 하지 않아야한다.
  - `효율성`
    - 빠르게 동작하는 코드
  - etc…

### 일회용 프로그램

- 언어가 해커에게 매력적으로 다가가려면 그들이 원하는 프로그램을 작성하기에 알맞아야 한다.
- 다소 놀랍겠지만 한번 작성하면 그걸로 끝인 일회용 프로그램을 만들기에 적당해야 한다는 의미다.
  - `일회용 프로그램` 이란 어떤 제한된 일을 수행하기 위해서 순식간에 작성하는 프로그램을 의미한다.
    - e.g. 시스템 관리자의 업무를 자동화 해주는 프로그램 등
  - 거대한 프로그램은 종종 처음부터 거대하게 설계된 것이 아니라 일회용 프로그램처럼 우연한 방식으로 시작한다.
  - 거대한 프로그램을 제작하는 다른 방법은 바로 일회용 프로그램을 만들어서 계속 발전시키는 것이다.
  - 이런 방식으로 작성된 프로그램은 지금까지도 처음 작성한 언어를 통해서 개선되고 있다
  - 해커에게 매력적인 언어는 바로 이 싸이클을 빠르게 할 수 있도록 하는 것이다. 그리고 유명세를 타는 것.

- **사람들이 알아채기 시작했을 때 당신이 거기 있어야 하는 것이 아니라, 사람들이 알아채기 시작했을 때 당신은 여전히 거기 있어야 하는 것이다.**
  - 중요한 순간을 맞이하기까지 일정한 시간이 걸리는 것은 보통이다.

### 재설계

- 가장 좋은 글쓰기는 다시 쓰는 것이다.
- 좋은 작품을 산출하는 사람들은 대개 그들이 일하는 동안에는 자기가 형편없는 작품을 만들고 있다고 생각한다.
  - 다른 사람들은 그 작품을 보고서 놀랍다고 생각을 하지만, 창조자는 오로지 결점만을 보게 된다.
  - 이러한 패턴은 우연이 아니다.
  - 근심이 좋은 작품을 만드는 것이다.
- **희망과 근심의 균형을 잘 잡아야한다.**
  - 희망은 어떤 문제를 놓고 그것을 풀 수 있다는 확신에 차서 미친 듯이 달린다.
    - 두 번째 단계에서는 자기가 한 일의 결과를 차가운 공기 속에서 바라보고, 그것이 가진 모든 결함을 명확하게 응시하게 된다.
    - 하지만 비판적 영혼이 희망을 완전히 압도하지 않는다면, 당신은 불완전한 시스템의 모습을 솔직히 인정하면서 남은 부분을 해결하는 것이 어려워 봤자 얼마나 어렵겠어. 라고 생각하게 된다.
    - **즉, 비판적 시각을 가지면서도 앞으로 나아갈 수 있는 건강한 사고를 가지는 것이다.**
  - 젊은 해커들에게는 낙관주의가 판을 친다. 그들은 뭔가를 만들어낸 다음, 그것이 위대하다고 확신하기 때문에 그것을 개선하려고 하지 않는다.
  - 나이 든 해커들은 비관주의가 우세하기 때문에 야심만만한 프로젝트를 떠맡으려고 하지도 않는다.
- **재설계의 순환과정이 제대로 이루어질 수 있도록 하는 것이라면 그게 무엇이라도 좋다.**

# 15. 디자인과 연구

- 디자인은 사용자에게 좀 더 관심을 기울이고
- 연구는 예상되는 사용자가 정확히 무엇을 필요로 하는지 알아낸다.
- 언어를 디자인하는 것과 연구하는 것은 다르다.
  - 디자인은 어떤 사람에게는 좋고 어떤 사람에게는 나쁘게 느껴질 수 있다.
- **수준이 낮은 사용자를 위해서 디자인을 하는 것이 어려운 이유는 바로 사기가 떨어지기 때문이다.**
  - **화가가 작품을 완성하는 경우는 없다. 단지 그는 작업을 멈출 뿐이다.**
  - 스스로 흥미를 느끼지 못한느 일에 대해서 지속적인 관심을 유지하는 것은 어렵다.
  - 뭔가 훌륭한 것을 만들기 위해서는 “엉터리 같군”보다는 “오 이건 정말 대단해”라는 생각을 할 필요가 있다.
- **디자인이라는 것은 결국 언제나 사람들을 위한 것이다. 하지만 사용자뿐만 아니라 디자이너도 사람이다.**
